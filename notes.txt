Goal: to build higher TF UniRenko bars: T16R80O1:
Trend=16 ticks
Reversal= 80 ticks
Offset= 1 tick

The data we are looking at is: 12/28/18.
The instrument is ES.
The format is "shrink". We will refer to this below as sourceData.
The sourceData has the following format:

dateTime, seqNum, volume, deltaFactor, occur, aggVol, aggDelta
2018-12-27T15:00:00,41,2491.50,1,-1,41,205,-5
2018-12-27T15:00:00,43,2491.25,1,-1,2,3,-2
2018-12-27T15:00:00,44,2491.00,1,-1,1,2,-1
2018-12-27T15:00:00,45,2491.25,1,1,1,2,1
2018-12-27T15:00:00,47,2491.50,1,1,2,3,0

Hours

Each 24-hour globex session is looked at in isolation. The implication of this 
approach is that at the end of a day any partial bar is closed, without regard 
to meeting its price target. Likewise, at the the start of a new session a new 
bar is always started. All times referenced at PT.  The globex sessions start 
at 15:00:00 and  end at 13:59:59 PT the following day. Additionally, there is a
brief halt at 13:14:59 and a resumption at 13:30:00.

UniRenko Bars

Bars are typically decribed by the canonical OHLC values: Open High, Low, 
and Close.  UniRenko bars have slighly different rules, so we will use a slightly
different nomenclature when we refer to them individually: uOpen, uHigh, uLow, 
and uClose. For the sake of brevity, "OHLC" will still be used to refer to them 
collectively.

How do we want to represent this new bar information?

If we add bar information to the sourceData, we pollute its information space.   
We will certainly want to use this same sourceData to create many other 
periodicities.  It is very likely a better option to create a new file that 
only references to this sourceData, without changing it.  This has the additional 
space-saving advantage of not replicating the sourceData every time we want to 
create a new periodicity. Further, the sourceData preserves the complete price 
movement history.  Creating a system that simply refers back to this history 
permits us to retain all the benefits this format implies, particularly the 
ability to reliably backtest.

Will we represent bar data with a single row for each bar? If we define the bar 
comprehensively in a single row we can omit barNumbers, as they are implied.  
There may be advantages, however, in defining a bar with multiple lines, in which 
case a barNumber may prove convenient.  Let's defer a final decision on this 
question for now, and simply add the barNumber.

We need to refer to the sourceData somehow.  The sourceData has a 
seqNum, which is session-unique. We will use this. Lastly, we need to specify 
what OHLC role a price (in the sourceData row) plays in this bar. So we now have:

barNum: 1-based index of the bar for the given session
seqNum: session-unique sourceData reference including time, vol, delta, etc
barRole: uOpen || uHigh || uLow || uClose

One possbility might be a single row/bar with pairs representing the OHLC
roles, like this:
seqNum, uOpen, seqNum, uHigh, seqNum, uLow, seqNum, uClose

This gets the job done. A barNumber is clearly optional and perhaps convenient.

An multi-row format might be:

barNum, seqNum, uOpen
barNum, seqNum, uHigh
barNum, seqNum, uLow
barNum, seqNum, uClose

This format would make it easier to filter rows based on barRole, should that
be desirable.

Let's step through the sourceData and build the first bar.  We will prepend 
line numbers for this discussion. They do not exist in the sourceData.

The day starts with:
1. 2018-12-27T15:00:00,41,2491.50,1,-1,41,205,-5

By definition, this is the uOpen of the 1st bar of the day. We note it as such.
(TODO: where?)

Since we have no way of knowing whether the first bar will be an upBar or a dnBar, 
the uOpen is also potentially the uHigh or uLow, as well.  Therefore, we must 
note this at the same time. (TODO: where?)

Next, we must compute target values, based on the Trend parameter 
(since the 1st bar of a session can never be a Reversal bar, it must be a 
Trend bar): 
price +/- Trend paremeters = target value
2491.50 + 16 ticks = 2495.50 (upTrend)
2491.50 - 16 ticks = 2487.50 (dnTrend)

Whichever price target we arrive at first determines the direction of this 
1st bar of the chart. In the meantime, in order to identify the the 
uHigh (if this becomes a dnBar) and the uLow (if this becomes an upBar) 
we will track new highs/lows:

  2. 2018-12-27T15:00:00,43,2491.25,1,-1,2,3,-2  // potential low
  3. 2018-12-27T15:00:00,44,2491.00,1,-1,1,2,-1 // new potential low
  6. 2018-12-27T15:00:00,49,2491.75,1,1,2,3,2 // potential high
 30. 2018-12-27T15:00:04,110,2492.00,1,1,5,7,6 // new potential high
 .
 .
 .
45. 2018-12-27T15:00:10,173,2490.75,1,-1,1,2,-1 // new pot low
.
.
.
etc
.
.
.
until, at row 217, we hit one of our targets:

217. 2018-12-27T15:02:22,916,2487.50,3,-1,4,10,-7 // low target hit!

At this point we know the uHigh occured 3x, the low kept getting lower until 
the target was hit. If we wanted to create a our 1st row for to represent this
1st bar, we have:
  1. 2018-12-27T15:00:00,41,2491.50,1,-1,41,205,-5 // uOpen
 30. 2018-12-27T15:00:04,110,2492.00,1,1,5,7,6 // also rows: 32, 35)
217. 2018-12-27T15:02:22,916,2487.50,3,-1,4,10,-7 uC // target hit: uLow and uClose 

For now let's use the multiple row format from above, with barNumbers:
// barNumber, seqNum, barRole
1,41,uOpen
1,110,uHigh
1,916,uLow
1,916,uClose

Note: For both Trend and Reversal bars, the Low (in a dnBar) or High (in an upBar) 
will always = the Close.  So the four roles (uOpen, uHigh, uLow, uClose) are always
representable with three values. The dnBar above could be trimmed down to:

1,41,uOpen
1,110,uHigh
1,916,uLow + uClose

if we had a way to comvbine uLow and uClose. Let's encode these values as a bitmap:

OHLC
8421

Now it looks like this:

1,41,8  // uOpen
1,110,4 // uHigh
1,916,3 // uLow + uClose

It is getting compact enough that it probably makes sense to just put it all in
a single row and eliminate the barNumbers:

// seqNum1, barRole1, seqNum2, barRole2, seqNum3, barRole3
41,8,110,4,916,3

For perspective, the tickData we started with for this day comprises about 75MB.
The priceChangeOnly sourceData referenced here shrunk that down or this day 
to 103,189 rows of priceChange data, occupying 4.9MB. This UniRenko bar 
file will contain 29 rows and about 1KB on disk. This file can be used to 
generate any indicators desired based on this periodicity. Backtesting will, 
of course, require the sourceData that it references.


What next?  Establish new targets, start a new bar.
2487.50 + 80 ticks = 2507.50 (Reversal) 
2487.50 - 16 ticks = 2483.50 (Trend)

Next, we need to calc the uOpen in case the trend continues down. In UniRenko bars
the uOpen is synthetic, permitting the bars to overlap by the specified Offset
parameter. It is calculated as follows:

If the current bar is a dnBar, operand is plus.
If the current bar is a upBar, operand is minus.

In this case we have a dnBar, so:
* bar[2].uOpen = bar[1].uClose plus Offset parameter  
*              = 2487.50 + .25 (1 tick)
*              = 2487.75 

We will now do this for every subsequent bar.

Rinse/repeat for every bar.
* calc uOpen
* track potential highs, lows
* monitor for target hit.

Make sure to finish by checking for last bar of sourceData
*********
don't forget to take last bar into account! so we need to run markLast prior to 
any of this
******


